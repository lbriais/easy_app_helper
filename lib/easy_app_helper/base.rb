################################################################################
# EasyAppHelper 
#
# Copyright (c) 2013 L.Briais under MIT license
# http://opensource.org/licenses/MIT
################################################################################

require 'slop'

# Once this module is included in your class which may be in the "application class",
# you probably want to call the init_app_helper method as first statement of your
# initialize method.
#
# This module provides some basic command line options ({using the slop gem}[https://rubygems.org/gems/slop])
# and 
# initializes all included EasyAppHelper modules (which may themselves add their
# own command line options). Calling the init_app_helper method is the only thing
# required to instanciate the whole framework.
#
# You can access to any command line option value through the app_config hash attribute.
#
# If you want to add any extra command line option to the one provided by default 
# by this module or by any other EasyAppHelper modules, then your class just needs
# to respond to add_specifc_command_line_options(opt).
# The opt object is a Slop object that enables to define any extra command line
# options.
#
# Passing the --help option to the program will cause this module to display the 
# inline help and to exit.
module EasyAppHelper::Base

  # This module should be processed among the firsts by the framework.
  MODULE_PRIORITY = 10

  include EasyAppHelper::Common


  @app_config = {}

  # Gives access to the application config. This should be the only attribute you will
  # use once this module is fully configured.
  attr_reader :app_config

  # Gives access to the initial command line options. Just for information as already 
  # merged into the app_config.
  def app_cmd_line_options
    @slop_definition.nil? ? {} : @slop_definition.to_hash
  end

  # This method initializes the whole EasyAppHelper helpers framework.
  # Even if only the first parameter is mandatory, you may pass all of them if you want
  # consistent inline help to be displayed.
  def init_app_helper(script_filename,
                      app_name="Undefined application name",
                      app_description="No description available",
                      app_version="unknown")
    # A brand new config is created.
    @app_config = {}
    # Initialize default options, and creates @slop_definition.
    build_default_command_line_options script_filename, app_name, app_description, app_version
    # Process all actions on EasyAppHelper modules that change app_config or add command
    # line options.
    process_helper_modules_init_config_actions script_filename, app_name, app_description, app_version
    # Provides possibility to the script writer to add its own command line options
    add_script_specific_cmd_line_options
    # Parses command line options, and merges with the app_config
    merge_cmd_line_options_into_config
    # Performs modules entry points
    process_helper_modules_entry_points
    # check if help is requested.
    check_help_option_invoked
    # Log useful debug info
    log_debug_info
  end



  # Returns the text of the inline help. Generated by Slop.
  def help
    @slop_definition.to_s
  end

  # Provides access to a standard logger, fully configured according to command line options
  # or config files.
  def logger
    return @logger unless @logger.nil?
    return EasyAppHelper::Common::DummyLogger.instance
  end


  ################################################################################
  private 

  # Checks EasyAppHelper modules and perform some actions on them.
  # - Does it add some command line options? Then add them by calling add_cmd_line_options
  # - Does it modify app_config? Then call provides_config. 
  def process_helper_modules_init_config_actions(script_filename, app_name, app_description, app_version)
    process_helper_modules do |mod|
      # Checks if th emodule adds some command line options
      if mod.respond_to? :add_cmd_line_options
        mod.add_cmd_line_options @slop_definition
      end
      # Does the module changing the application config
      if mod.respond_to? :provides_config
        module_config = mod.provides_config(script_filename, app_name, app_description, app_version) 
        @app_config = EasyAppHelper::Common.override_config app_config, module_config
      end
    end
  end

  # Call each initialization entry point for modules if any.
  def process_helper_modules_entry_points
    process_helper_modules do |mod|
      if mod.respond_to? :module_entry_point
        if self.respond_to? mod.module_entry_point
          begin
            logger.debug "Executing #{mod.name} module post actions."
            self.send(mod.module_entry_point)
            logger.debug "Module #{mod.name} post actions executed."
          rescue => e
            logger.fatal "Problem encountered while executing #{mod.name} module post actions."
            raise e
          end
        else
          raise "Wrong module entry point specified !"
        end
      else
        logger.debug "Module #{mod.name} has no post config action."
      end
    end
  end

  # Utility method to process EasyAppHelper modules in order of priority.
  def process_helper_modules
    self.class.included_modules
      .map {|mod| mod if mod.name =~ /^EasyAppHelper::/}
      .compact
      .sort {|a,b| a::MODULE_PRIORITY <=> b::MODULE_PRIORITY }
      .each {|mod| yield mod}
  end

  def merge_cmd_line_options_into_config
    @slop_definition.parse!
    @app_config = EasyAppHelper::Common.override_config app_config, @slop_definition.to_hash
  end

  # Builds common used command line options
  def build_default_command_line_options(script_filename, app_name, app_description, app_version)
    # Default options
    @slop_definition = Slop.new do
      banner "\nUsage: #{script_filename} [options]\n#{app_name} Version: #{app_version}\n\n#{app_description}"
      separator "-- Generic options -------------------------------------------"
      on :auto, 'Auto mode. Bypasses questions to user.', :argument => false
      on :simulate, 'Do not perform the actual underlying actions.', :argument => false
      on :v, :verbose, 'Enable verbose mode.', :argument => false
      on :h, :help, 'Displays this help.', :argument => false
    end
  end

  # Hook for the script to add its own command line options
  #
  # Just need to implement a add_specifc_command_line_options method that tal=ke a slop object as parameter
  def add_script_specific_cmd_line_options
    if self.respond_to? :add_specifc_command_line_options
      @slop_definition.separator "\n-- Script specific options------------------------------------"
      self.add_specifc_command_line_options @slop_definition
    end
  end

  # Check if the help command line option has been passed and if the case,
  # display the inline help and exits the program.
  def check_help_option_invoked
    return unless app_config[:help]
    puts self.help
    exit 0
  end

  # Displays useful debug info after all EasyAppHelper modules initialization.
  def log_debug_info
    return unless app_config[:debug] || app_config[:'debug-on-err']
    size = ENV.keys.map {|k| k.length }.max + 1
    logger.debug '-' * 80
    logger.debug " Script environment variables"
    logger.debug '-' * 80
    # print formatted environment
    ENV.sort.each {|k,v| logger.debug "- %-#{size}s %s" % ["#{k}:", v] }
    logger.debug '-' * 80
    logger.debug " Script Ruby load path"
    logger.debug '-' * 80
    $:.each {|p| logger.debug p}
    logger.debug '-' * 80
    logger.debug " Script command line parameters"
    logger.debug '-' * 80
    size = app_cmd_line_options.to_hash.keys.map {|k| k.length }.max + 1
    app_cmd_line_options.to_hash.sort.each {|k,v| logger.debug "- %-#{size}s %s" % ["#{k}:", v] }
    logger.debug '-' * 80
    logger.debug " Script global configuration"
    logger.debug '-' * 80
    logger.debug "\n" + app_config.to_yaml
    logger.debug '-' * 80
  end

end


